{"version":3,"sources":["contextData.ts","konvaFunctions.ts","InputArea.tsx","defaultConfig.ts","ClippingBox.tsx","Exhibition.tsx","OutputArea.tsx","canvasFunctions.ts","App.tsx","index.tsx"],"names":["boxesPropsContext","createContext","setBoxesPropsContext","useBoxesProps","useContext","useSetBoxesProps","getRelativePointerPosition","ref","current","node","transform","getAbsoluteTransform","copy","invert","pos","getStage","getPointerPosition","point","SelectionRect","beginPos","endPos","x","y","width","height","fill","stroke","opacity","InputArea","layoutSize","setBoxesProps","useState","mouseDownPos","setMouseDownPos","dragging","setDragging","inputAreaRef","useRef","className","onMouseDown","onMouseUp","mouseUpPos","preState","Math","min","abs","key","length","cropX","cropY","cropWidth","cropHeight","addBoxProps","videoConstraints","facingMode","cameraSize","ClippingBoxes","currentFrame","boxProps","isSelected","onSelect","onChange","shapeRef","transformerRef","useEffect","nodes","getLayer","batchDraw","onClick","onDragEnd","e","target","onTransformEnd","scaleX","scaleY","max","image","strokeWidth","draggable","boundBoxFunc","oldBox","newBox","rotateEnabled","Exhibition","selectedKey","setSelectedKey","boxesProps","undefined","map","i","ClippingBox","newProps","boxes","OutputArea","baseCanvas","Provider","value","createCanvas","size","canvas","document","createElement","App","setBaseCanvas","cameraRef","frameInterval","setInterval","canvasSize","video","ctx","getContext","drawImage","getImageData","l","data","grayscale","s","makeGrayscale","putImageData","refreshFrame","clearInterval","id","audio","style","position","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.3ad1edfe.chunk.js","sourcesContent":["import { createContext, Dispatch, SetStateAction, useContext } from \"react\";\r\n\r\nexport const boxesPropsContext = createContext<BoxProps[]>([]);\r\nexport const setBoxesPropsContext = createContext<\r\n  Dispatch<SetStateAction<BoxProps[]>>\r\n>(() => {});\r\n\r\nexport const useBoxesProps = () => useContext(boxesPropsContext);\r\nexport const useSetBoxesProps = () => useContext(setBoxesPropsContext);\r\n","import Konva from \"konva\";\r\nimport { Vector2d } from \"konva/types/types\";\r\n\r\nconst getRelativePointerPosition = (\r\n  ref: React.RefObject<Konva.Stage>\r\n): Vector2d | null => {\r\n  if (!ref.current) return null;\r\n  const node = ref.current;\r\n  const transform = node.getAbsoluteTransform().copy();\r\n  transform.invert();\r\n  const pos = node.getStage().getPointerPosition();\r\n\r\n  return pos ? transform.point(pos) : null;\r\n};\r\n\r\nexport { getRelativePointerPosition };\r\n","import React, { useState, useRef } from \"react\";\r\nimport { Layer, Stage, Rect } from \"react-konva\";\r\nimport { useSetBoxesProps } from \"./contextData\";\r\n\r\nimport Konva from \"konva\";\r\nimport { Vector2d } from \"konva/types/types\";\r\nimport { getRelativePointerPosition } from \"./konvaFunctions\";\r\n\r\nconst SelectionRect: React.FC<{\r\n  beginPos: Vector2d;\r\n  endPos: Vector2d;\r\n}> = ({ beginPos, endPos }) => {\r\n  return (\r\n    <Rect\r\n      x={beginPos.x}\r\n      y={beginPos.y}\r\n      width={endPos.x - beginPos.x}\r\n      height={endPos.y - beginPos.y}\r\n      fill={\"blue\"}\r\n      stroke={\"red\"}\r\n      opacity={0.2}\r\n    />\r\n  );\r\n};\r\n\r\nconst InputArea: React.FC<{\r\n  layoutSize: RectSize;\r\n}> = ({ layoutSize }) => {\r\n  const setBoxesProps = useSetBoxesProps();\r\n  const [mouseDownPos, setMouseDownPos] = useState<Vector2d>({ x: 0, y: 0 });\r\n  const [dragging, setDragging] = useState<Boolean>(false);\r\n\r\n  const inputAreaRef = useRef<Konva.Stage>(null);\r\n\r\n  const addBoxProps = () => {\r\n    const mouseUpPos = getRelativePointerPosition(inputAreaRef) ?? {\r\n      x: 0,\r\n      y: 0,\r\n    };\r\n\r\n    setBoxesProps((preState) => [\r\n      ...preState,\r\n      (() => {\r\n        // 左上頂点で座標を管理\r\n        const x = Math.min(mouseDownPos.x, mouseUpPos.x);\r\n        const y = Math.min(mouseDownPos.y, mouseUpPos.y);\r\n        const width = Math.abs(mouseDownPos.x - mouseUpPos.x);\r\n        const height = Math.abs(mouseDownPos.y - mouseUpPos.y);\r\n\r\n        return {\r\n          key: preState.length,\r\n          cropX: x,\r\n          cropY: y,\r\n          cropWidth: width,\r\n          cropHeight: height,\r\n          x,\r\n          y,\r\n          width,\r\n          height,\r\n        };\r\n      })(),\r\n    ]);\r\n  };\r\n\r\n  return (\r\n    <Stage\r\n      className=\"input-area\"\r\n      width={layoutSize.width}\r\n      height={layoutSize.height}\r\n      ref={inputAreaRef}\r\n      onMouseDown={() => {\r\n        setMouseDownPos(\r\n          getRelativePointerPosition(inputAreaRef) ?? { x: 0, y: 0 }\r\n        );\r\n        setDragging(true);\r\n      }}\r\n      onMouseUp={() => {\r\n        addBoxProps();\r\n        setDragging(false);\r\n      }}\r\n    >\r\n      <Layer>\r\n        {dragging ? (\r\n          <SelectionRect\r\n            beginPos={mouseDownPos}\r\n            endPos={getRelativePointerPosition(inputAreaRef) ?? { x: 0, y: 0 }}\r\n            // FIXME: endPosの更新タイミングで描画されず、baseCanvasの更新により描画されている。\r\n          />\r\n        ) : null}\r\n      </Layer>\r\n    </Stage>\r\n  );\r\n};\r\n\r\nexport default InputArea;\r\n","import Webcam from \"react-webcam\";\r\n\r\nexport const videoConstraints: Webcam[\"props\"][\"videoConstraints\"] = {\r\n  width: 1280,\r\n  height: 720,\r\n  facingMode: \"user\",\r\n};\r\n\r\nexport const cameraSize = {\r\n  ...videoConstraints,\r\n} as RectSize;\r\n\r\nexport const minimumBoxSize = 2;\r\n","import React, { useEffect, useRef } from \"react\";\r\nimport { Image, Transformer } from \"react-konva\";\r\n\r\nimport Konva from \"konva\";\r\nimport { minimumBoxSize } from \"./defaultConfig\";\r\n\r\nconst ClippingBoxes: React.FC<{\r\n  currentFrame: CanvasImageSource;\r\n  boxProps: BoxProps;\r\n  isSelected: boolean;\r\n  onSelect: () => void;\r\n  onChange: (newProps: BoxProps) => void;\r\n}> = ({ currentFrame, boxProps, isSelected, onSelect, onChange }) => {\r\n  const shapeRef = useRef<Konva.Image>(null);\r\n  const transformerRef = useRef<Konva.Transformer>(null);\r\n\r\n  useEffect(() => {\r\n    // trasformerは手動でアタッチしなければならない\r\n    if (isSelected) {\r\n      transformerRef.current?.nodes([shapeRef.current!]);\r\n      transformerRef.current?.getLayer()?.batchDraw();\r\n    }\r\n  }, [isSelected]);\r\n\r\n  return (\r\n    <>\r\n      <Image\r\n        ref={shapeRef}\r\n        onClick={onSelect}\r\n        onDragEnd={(e) => {\r\n          onChange({\r\n            ...boxProps,\r\n            x: e.target.x(),\r\n            y: e.target.y(),\r\n          });\r\n        }}\r\n        onTransformEnd={() => {\r\n          // FIXME: 変形中は表示倍率を変更しているため枠線にも影響が出るのに対し、\r\n          // 変形後は枠線の幅が戻るため、結果を確認しながら操作ができなくなっている。\r\n\r\n          // transformerはnodeのscaleを変更し、widthとheightはそのまま。\r\n          // しかし、データの管理を容易にするため、変形終了時にスケールをリセットする。\r\n          const node = shapeRef.current!;\r\n          const scaleX = node.scaleX();\r\n          const scaleY = node.scaleY();\r\n\r\n          // もとに戻す\r\n          node.scaleX(1);\r\n          node.scaleY(1);\r\n\r\n          onChange({\r\n            ...boxProps,\r\n            x: node.x(),\r\n            y: node.y(),\r\n            // 最小値を指定する\r\n            width: Math.max(minimumBoxSize, node.width() * scaleX),\r\n            height: Math.max(minimumBoxSize, node.height() * scaleY),\r\n          });\r\n        }}\r\n        {...boxProps} // REVIEW: ここにkeyが展開されるのは余計か？\r\n        image={currentFrame}\r\n        stroke={\"black\"}\r\n        strokeWidth={10}\r\n        draggable\r\n      />\r\n      {isSelected && (\r\n        <Transformer\r\n          ref={transformerRef}\r\n          boundBoxFunc={(oldBox, newBox) => {\r\n            // リサイズ制限\r\n            return newBox.width < minimumBoxSize ||\r\n              newBox.height < minimumBoxSize\r\n              ? oldBox\r\n              : newBox;\r\n          }}\r\n          rotateEnabled={false}\r\n        />\r\n      )}\r\n    </>\r\n  );\r\n};\r\n\r\nexport default ClippingBoxes;\r\n","import React, { useState } from \"react\";\r\nimport { Layer, Image } from \"react-konva\";\r\nimport ClippingBox from \"./ClippingBox\";\r\nimport { useBoxesProps, useSetBoxesProps } from \"./contextData\";\r\n\r\nconst Exhibition: React.FC<{\r\n  currentFrame: CanvasImageSource;\r\n}> = ({ currentFrame }) => {\r\n  const [selectedKey, setSelectedKey] = useState<number>();\r\n\r\n  const boxesProps = useBoxesProps();\r\n  const setBoxesProps = useSetBoxesProps();\r\n\r\n  const checkDeselect = () => {\r\n    // 背景をクリックしたとき選択を解除\r\n    setSelectedKey(undefined);\r\n  };\r\n\r\n  return (\r\n    <Layer>\r\n      <Image image={currentFrame} onMouseDown={checkDeselect} />\r\n      {(() =>\r\n        boxesProps.map((boxProps, i) => (\r\n          <ClippingBox\r\n            key={boxProps.key}\r\n            boxProps={boxProps}\r\n            currentFrame={currentFrame}\r\n            isSelected={boxProps.key === selectedKey}\r\n            onSelect={() => {\r\n              setSelectedKey(boxProps.key);\r\n            }}\r\n            onChange={(newProps: BoxProps) => {\r\n              const boxes = [...boxesProps];\r\n              boxes[i] = newProps;\r\n              setBoxesProps(boxes);\r\n            }}\r\n          />\r\n        )))()}\r\n    </Layer>\r\n  );\r\n};\r\n\r\nexport default Exhibition;\r\n","import React from \"react\";\r\nimport { Stage } from \"react-konva\";\r\nimport Exhibition from \"./Exhibition\";\r\nimport {\r\n  useBoxesProps,\r\n  boxesPropsContext,\r\n  useSetBoxesProps,\r\n  setBoxesPropsContext,\r\n} from \"./contextData\";\r\n\r\nconst OutputArea: React.FC<{\r\n  layoutSize: RectSize;\r\n  baseCanvas: CanvasImageSource;\r\n}> = ({ layoutSize, baseCanvas }) => {\r\n  // Contextは<Stage>を通り抜けないためブリッジする必要がある\r\n  const boxesProps = useBoxesProps();\r\n  const setBoxesProps = useSetBoxesProps();\r\n\r\n  return (\r\n    <Stage\r\n      className=\"output-area\"\r\n      width={layoutSize.width}\r\n      height={layoutSize.height}\r\n    >\r\n      <setBoxesPropsContext.Provider value={setBoxesProps}>\r\n        <boxesPropsContext.Provider value={boxesProps}>\r\n          <Exhibition currentFrame={baseCanvas} />\r\n        </boxesPropsContext.Provider>\r\n      </setBoxesPropsContext.Provider>\r\n    </Stage>\r\n  );\r\n};\r\n\r\nexport default OutputArea;\r\n","export const createCanvas = (size: RectSize) => {\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = size.width;\r\n  canvas.height = size.height;\r\n\r\n  return canvas;\r\n};\r\n\r\n// グレイスケールならCSSでもできる。その場合はcanvasごとにフィルターがかかるため構造を変える必要がありそう。\r\nexport const makeGrayscale = (image: ImageData) => {\r\n  const l = image.data.length / 4; // RGBA\r\n  for (let i = 0; i < l; i++) {\r\n    const grayscale =\r\n      image.data[i * 4 + 0] * 0.299 +\r\n      image.data[i * 4 + 1] * 0.587 +\r\n      image.data[i * 4 + 2] * 0.114;\r\n\r\n    const s = (grayscale * grayscale) / 255 / 255;\r\n\r\n    image.data[i * 4 + 0] = (s + 0.008) * 255;\r\n    image.data[i * 4 + 1] = (s + 0.014) * 255 + 1.9;\r\n    image.data[i * 4 + 2] = (s + 0.004) * 255;\r\n  }\r\n};\r\n","import React, { useState, useRef, useEffect } from \"react\";\r\nimport Webcam from \"react-webcam\";\r\nimport InputArea from \"./InputArea\";\r\nimport OutputArea from \"./OutputArea\";\r\nimport { setBoxesPropsContext, boxesPropsContext } from \"./contextData\";\r\n\r\nimport { createCanvas, makeGrayscale } from \"./canvasFunctions\";\r\nimport { cameraSize, videoConstraints } from \"./defaultConfig\";\r\n\r\nconst App: React.FC = () => {\r\n  const [baseCanvas, setBaseCanvas] = useState(createCanvas(cameraSize));\r\n  const [boxesProps, setBoxesProps] = useState<BoxProps[]>([]);\r\n\r\n  const cameraRef = useRef<Webcam>(null);\r\n  const frameInterval = useRef<NodeJS.Timeout>();\r\n\r\n  const FPS = 60;\r\n  useEffect(() => {\r\n    const refreshFrame = (canvasSize: RectSize) => {\r\n      if (!(cameraRef.current && cameraRef.current.video)) return;\r\n      const ctx = createCanvas(canvasSize).getContext(\"2d\");\r\n\r\n      if (!ctx) return;\r\n      ctx.drawImage(cameraRef.current.video, 0, 0);\r\n\r\n      const image = ctx.getImageData(0, 0, canvasSize.width, canvasSize.height);\r\n      makeGrayscale(image);\r\n      ctx.putImageData(image, 0, 0);\r\n\r\n      setBaseCanvas(ctx.canvas);\r\n    };\r\n\r\n    frameInterval.current = setInterval(\r\n      () => refreshFrame(cameraSize),\r\n      1000 / FPS\r\n    );\r\n\r\n    return () => {\r\n      clearInterval(frameInterval.current!);\r\n    };\r\n  }, [FPS]);\r\n\r\n  return (\r\n    <section id=\"app\">\r\n      <Webcam\r\n        id=\"camera\"\r\n        ref={cameraRef}\r\n        audio={false}\r\n        videoConstraints={videoConstraints}\r\n        width={cameraSize.width}\r\n        height={cameraSize.height}\r\n        style={{ position: \"absolute\" }}\r\n      />\r\n      <setBoxesPropsContext.Provider value={setBoxesProps}>\r\n        <boxesPropsContext.Provider value={boxesProps}>\r\n          <InputArea layoutSize={cameraSize} />\r\n          <OutputArea layoutSize={cameraSize} baseCanvas={baseCanvas} />\r\n        </boxesPropsContext.Provider>\r\n      </setBoxesPropsContext.Provider>\r\n    </section>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}